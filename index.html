<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åœ£è¯æ ‘ ğŸ„ (3Dç¤¼ç‰©ç¥ç¦ç‰ˆ)</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      font-family: system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at top, #062015 0%, #02050c 55%, #000 100%);
      color: #fff;
    }
    #app { position: fixed; inset: 0; z-index: 1; cursor: grab; }
    #app:active { cursor: grabbing; }

    .overlay {
      position: fixed; top: 18px; left: 50%; transform: translateX(-50%);
      text-align: center; pointer-events: none; z-index: 10; width: 100%;
    }
    .title {
      font-size: clamp(24px, 3vw, 32px); letter-spacing: 0.25em; text-transform: uppercase;
      text-shadow: 0 0 10px rgba(200, 255, 160, 0.8), 0 0 24px rgba(120, 220, 120, 0.8);
    }
    .subtitle { margin-top: 6px; font-size: 14px; opacity: 0.9; letter-spacing: 0.06em; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
    .countdown { margin-top: 8px; font-size: 11px; opacity: 0.7; font-family: monospace; }

    /* éŸ³ä¹æŒ‰é’® */
    .music-btn {
      position: fixed; top: 20px; right: 20px; z-index: 20;
      width: 40px; height: 40px; border-radius: 50%;
      background: rgba(255,255,255,0.15); backdrop-filter: blur(4px);
      border: 1px solid rgba(255,255,255,0.3);
      cursor: pointer; display: flex; align-items: center; justify-content: center;
      transition: all 0.3s;
    }
    .music-btn:hover { background: rgba(255,255,255,0.3); transform: scale(1.1); }
    .music-btn.playing { animation: spin 4s linear infinite; border-color: #8f8; }
    @keyframes spin { 100% { transform: rotate(360deg); } }

    /* è½¬å‘/å†™ç¥ç¦æŒ‰é’® */
    .share-btn {
      position: fixed; bottom: 30px; right: 30px; z-index: 20;
      padding: 12px 24px; border-radius: 50px;
      background: linear-gradient(135deg, #d11919 0%, #ff3333 100%);
      border: 2px solid rgba(255,255,255,0.5); color: #fff;
      cursor: pointer; font-size: 14px; font-weight: bold; transition: 0.3s;
      box-shadow: 0 5px 20px rgba(200, 0, 0, 0.5);
      display: flex; align-items: center; gap: 8px; letter-spacing: 1px;
    }
    .share-btn:hover { transform: scale(1.05) translateY(-2px); filter: brightness(1.1); }
    .share-btn:active { transform: scale(0.95); }

    .lil-gui { top: 20px !important; left: 20px !important; }

    /* æ‘„åƒå¤´çŠ¶æ€ (éšå½¢) */
    .cam-status-bar {
        position: fixed; bottom: 30px; left: 30px; z-index: 30;
        display: flex; flex-direction: column; align-items: flex-start; gap: 8px;
    }
    #cameraBtn {
        padding: 8px 16px; border-radius: 20px;
        background: rgba(0, 255, 128, 0.15); backdrop-filter: blur(4px);
        border: 1px solid rgba(0, 255, 128, 0.4); color: #cfc;
        cursor: pointer; font-size: 12px; transition: 0.3s;
    }
    #cameraBtn:hover { background: rgba(0, 255, 128, 0.3); }

    .status-text {
        font-size: 12px; font-family: monospace;
        color: rgba(255,255,255,0.7);
        background: rgba(0,0,0,0.5); padding: 4px 8px; border-radius: 4px;
        opacity: 0; transition: opacity 0.3s; pointer-events: none;
        white-space: pre-wrap; line-height: 1.4;
    }
    .status-text.active { opacity: 1; }

    #input_video { display: none; }

    #loading {
        position: fixed; inset: 0; background: #000; z-index: 100;
        display: flex; justify-content: center; align-items: center;
        color: #8f8; font-family: monospace; transition: opacity 0.5s;
    }

    /* === ç¤¼ç‰©å¡ç‰‡å¼¹çª— === */
    #modal-overlay {
        position: fixed; inset: 0; z-index: 50;
        display: none; justify-content: center; align-items: center;
        background: rgba(0,0,0,0.7); backdrop-filter: blur(8px);
        animation: fadeIn 0.3s ease-out;
    }
    .card {
        background: #fff;
        width: 85%; max-width: 400px;
        padding: 40px 30px; border-radius: 4px; /* æ‹ç«‹å¾—é£æ ¼/ä¿¡çº¸é£æ ¼ */
        text-align: center; color: #333;
        box-shadow: 0 20px 50px rgba(0,0,0,0.6);
        transform: scale(0.8);
        animation: popUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        position: relative;
        border: 1px solid #eee;
    }
    .card::before {
        content: ''; position: absolute; top: 0; left: 0; right: 0; height: 6px;
        background: repeating-linear-gradient(45deg, #d11919, #d11919 10px, #fff 10px, #fff 20px);
    }
    .card-icon { font-size: 60px; margin-bottom: 20px; display: block; filter: drop-shadow(0 4px 4px rgba(0,0,0,0.2)); }
    .card-title { font-size: 14px; font-weight: bold; margin-bottom: 20px; color: #888; text-transform: uppercase; letter-spacing: 2px;}
    .card-msg {
        font-size: 20px; line-height: 1.6; margin-bottom: 30px;
        font-family: "Georgia", serif; font-style: italic; color: #222; word-wrap: break-word;
    }
    .card-btn {
        padding: 10px 30px; background: #d11919; color: white; border: none;
        border-radius: 50px; font-size: 14px; font-weight: bold; cursor: pointer; transition: 0.2s;
    }
    .card-btn:hover { background: #b01515; transform: translateY(-2px); box-shadow: 0 4px 10px rgba(200,0,0,0.3); }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes popUp { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <script src="//code.bdstatic.com/npm/leancloud-storage@4.12.0/dist/av-min.js"></script>
</head>
<body>
  <div id="loading">Loading Christmas Magic...</div>
  <div id="app"></div>

  <div class="overlay">
    <div class="title">MERRY CHRISTMAS</div>
    <div class="subtitle" id="wish-line"></div>
    <div class="countdown" id="countdown"></div>
  </div>

  <div class="music-btn" id="musicBtn" title="Play Music">
    <div class="music-icon">ğŸµ</div>
  </div>
  <audio id="bgm" loop src="https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3?filename=christmas-magic-126466.mp3"></audio>

  <div class="share-btn" id="shareBtn">ğŸ å†™ç¥ç¦ & è½¬å‘</div>

  <div class="cam-status-bar">
      <button id="cameraBtn">ğŸ“· å¼€å¯æ‰‹åŠ¿æ§åˆ¶</button>
      <div class="status-text" id="gestureStatus">ç³»ç»Ÿå¾…æœºä¸­...</div>
  </div>
  <video id="input_video"></video>

  <div id="modal-overlay">
      <div class="card">
          <div class="card-icon">ğŸ</div>
          <div class="card-title">Secret Message</div>
          <div class="card-msg" id="modal-msg">...</div>
          <button class="card-btn" onclick="document.getElementById('modal-overlay').style.display='none'">æ”¶ä¸‹ç¥ç¦</button>
      </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/shaders/CopyShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

  <script>
    // ==========================================
    // âš ï¸ æ•°æ®åº“é…ç½® (LeanCloud)
    // ==========================================
    const LC_APP_ID = "rJAYmAqHbtWgjmpA7Cve58Ym-MdYXbMMI"; // è¯·å¡«å…¥
    const LC_APP_KEY = "rqtdjtHFUfcXzBQOUbfOZkha"; // è¯·å¡«å…¥
    const LC_SERVER_URL = "https://your_server_url.api.lncldglobal.com";

    // é»˜è®¤æ¼”ç¤ºç¥ç¦
    const MOCK_WISHES = [
        "Merry Christmas! ğŸ„", "å¹³å®‰å–œä¹ ğŸ", "2025 æš´å¯Œ ğŸ’°",
        "Happy New Year âœ¨", "ä¸‡äº‹èƒœæ„ ğŸ®", "èº«ä½“å¥åº· ğŸ’ª", "å¥½è¿è¿è¿ ğŸ€"
    ];

    window.addEventListener('load', function() {
        if (typeof THREE === 'undefined') {
            document.getElementById('loading').innerText = "èµ„æºåŠ è½½å¤±è´¥"; return;
        }
        const loadingEl = document.getElementById('loading');
        loadingEl.style.opacity = '0';
        setTimeout(() => loadingEl.remove(), 500);

        // === 1. æ•°æ®åº“åˆå§‹åŒ– ===
        let isDbReady = false;
        if (LC_APP_ID !== "YOUR_APP_ID" && typeof AV !== 'undefined') {
            try {
                const config = { appId: LC_APP_ID, appKey: LC_APP_KEY };
                if (LC_SERVER_URL.startsWith("http")) config.serverURL = LC_SERVER_URL;
                AV.init(config);
                isDbReady = true;
                console.log("äº‘ç«¯æ•°æ®åº“è¿æ¥æˆåŠŸ");
            } catch(e) { console.log("æ•°æ®åº“è¿æ¥å¤±è´¥", e); }
        }

        // === 2. URL å‚æ•° & åˆå§‹ç¥ç¦ (ä¿ç•™åŸç‰ˆé€»è¾‘) ===
        const params = new URLSearchParams(window.location.search);
        // è¿™æ˜¯ç”¨æˆ·é€šè¿‡è½¬å‘é“¾æ¥å¸¦è¿‡æ¥çš„ç¥ç¦
        let globalWishText = params.get("wish") || params.get("msg") || "Wishing you peace, joy & love.";
        const el = document.getElementById("wish-line");
        if (el) el.textContent = globalWishText.slice(0, 80);

        // === 3. ä¸Šä¼  & è½¬å‘é€»è¾‘ ===
        document.getElementById('shareBtn').addEventListener('click', async () => {
            const input = prompt("âœï¸ å†™ä¸‹ä¸€å¥ç¥ç¦\nå®ƒå°†å˜æˆ3Dç¤¼ç‰©ç›’é£˜åœ¨äº‘ç«¯ï¼Œå¹¶ç”Ÿæˆé“¾æ¥ä¾›ä½ è½¬å‘ï¼š", globalWishText);
            if (input && input.trim()) {
                const text = input.trim().slice(0, 60);

                // A. å­˜å…¥äº‘ç«¯ (ç”Ÿæˆ3Dç›’å­)
                if (isDbReady) {
                    try {
                        const WishObject = AV.Object.extend('Wishes');
                        const wish = new WishObject();
                        wish.set('content', text);
                        await wish.save();
                        createFloatingGift(text); // ç«‹å³åœ¨æœ¬åœ°ç”Ÿæˆä¸€ä¸ª
                        alert("âœ… ç¥ç¦å·²ä¸Šå¢™ï¼\né“¾æ¥å·²å¤åˆ¶ï¼Œå¿«å»å‘ç»™æœ‹å‹å§ï¼");
                    } catch (error) {
                        alert("å‘å¸ƒå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œã€‚");
                    }
                } else {
                    alert("âœ… (æ¼”ç¤ºæ¨¡å¼) ç¥ç¦å·²ä¸Šå¢™ï¼\né“¾æ¥å·²å¤åˆ¶ï¼Œå¿«å»å‘ç»™æœ‹å‹å§ï¼");
                    createFloatingGift(text);
                }

                // B. ç”Ÿæˆè½¬å‘é“¾æ¥ (æ ¸å¿ƒéœ€æ±‚)
                const url = new URL(window.location.href);
                url.searchParams.set('wish', text);
                navigator.clipboard.writeText(url.toString()).then(() => {
                    console.log("è½¬å‘é“¾æ¥å·²å¤åˆ¶");
                }).catch(() => {});
            }
        });

        async function fetchWishes() {
            if (isDbReady) {
                try {
                    const query = new AV.Query('Wishes');
                    query.descending('createdAt');
                    query.limit(40); // æ‹¿æœ€è¿‘40æ¡
                    const results = await query.find();
                    const msgs = results.map(r => r.get('content'));
                    return msgs.length > 0 ? msgs : MOCK_WISHES;
                } catch (e) { return MOCK_WISHES; }
            }
            return MOCK_WISHES;
        }

        // === 4. æ‰‹åŠ¿æ§åˆ¶ ===
        const interaction = { isGrabbing: false, explosionFactor: 0.0 };
        let isCameraRunning = false;
        let gestureRotateSpeed = 0.5;
        let targetCameraY = 30;
        let currentCameraY = 30;

        const videoElement = document.getElementById('input_video');
        const gestureStatus = document.getElementById('gestureStatus');
        const cameraBtn = document.getElementById('cameraBtn');

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                gestureStatus.classList.add('active');
                const landmarks = results.multiHandLandmarks[0];

                // çˆ†ç‚¸ï¼ˆåªæœ‰æ‰‹åŠ¿æ§åˆ¶ interaction.isGrabbingï¼‰
                let extended = 0;
                const tips = [8, 12, 16, 20]; const bases = [5, 9, 13, 17];
                const wrist = landmarks[0];
                function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }
                for (let i = 0; i < 4; i++) {
                    if (dist(wrist, landmarks[tips[i]]) > dist(wrist, landmarks[bases[i]]) * 1.3) extended++;
                }
                if (dist(landmarks[4], landmarks[17]) > 0.15) extended++;

                let sStr = "";
                if (extended >= 4) { interaction.isGrabbing = true; sStr = "ğŸ–ï¸ çˆ†ç‚¸ | "; }
                else if (extended <= 2) { interaction.isGrabbing = false; sStr = "âœŠ æ”¶ç¼© | "; }

                // æ—‹è½¬
                const handX = landmarks[9].x;
                const offset = (0.5 - handX) * 35.0;
                gestureRotateSpeed += (offset - gestureRotateSpeed) * 0.1;
                let hStr = "â†”ï¸";
                if(handX > 0.6) hStr = "âª"; if(handX < 0.4) hStr = "â©";

                // é«˜åº¦
                const handY = landmarks[9].y;
                targetCameraY = 5 + (1.0 - handY) * 90;

                gestureStatus.innerText = `${sStr}${hStr}`;
            } else {
                interaction.isGrabbing = false;
                gestureStatus.classList.remove('active');
                gestureRotateSpeed += (0.5 - gestureRotateSpeed) * 0.05;
                targetCameraY += (30 - targetCameraY) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        cameraBtn.addEventListener('click', () => {
            if (isCameraRunning) return;
            cameraBtn.innerText = "å¯åŠ¨ä¸­...";
            const camera = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            camera.start().then(() => {
                isCameraRunning = true;
                cameraBtn.innerText = "ğŸŸ¢ æ‰‹åŠ¿å·²æ¿€æ´»";
                cameraBtn.style.color = "#8f8";
                gestureStatus.classList.add('active');
            });
        });

        // éŸ³ä¹
        const musicBtn = document.getElementById('musicBtn');
        const audio = document.getElementById('bgm');
        let isPlaying = false;
        musicBtn.addEventListener('click', () => {
          if (isPlaying) { audio.pause(); musicBtn.classList.remove('playing'); musicBtn.innerHTML = '<div class="music-icon">ğŸµ</div>'; }
          else { audio.play().then(() => { musicBtn.classList.add('playing'); musicBtn.innerHTML = '<div class="music-icon">â¸</div>'; }).catch(e => console.log(e)); }
          isPlaying = !isPlaying;
        });

        // å€’è®¡æ—¶
        function updateCountdown() {
          const now = new Date(); const currentYear = now.getFullYear(); let xmas = new Date(currentYear, 11, 25);
          if (now.getMonth() === 11 && now.getDate() > 25) xmas.setFullYear(currentYear + 1);
          const diff = xmas - now;
          const days = Math.floor(diff / (1000 * 60 * 60 * 24));
          document.getElementById('countdown').innerText = days >= 0 ? `Countdown: ${days} days` : "MERRY CHRISTMAS!";
        }
        setInterval(updateCountdown, 1000); updateCountdown();

        // âš ï¸ è¿™é‡Œä¸å†ç”¨é¼ æ ‡/è§¦æ§å»æ”¹ interaction.isGrabbingï¼Œé¿å…ç‚¹å‡»è§¦å‘çˆ†ç‚¸
        // ä»…ä¿ç•™ç‚¹å‡»äº‹ä»¶ç”¨äºç‚¹ç¤¼ç‰©/æ‰“å¼€å¡ç‰‡

        // === Three.js åœºæ™¯ ===
        const container = document.getElementById('app');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.004);
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.set(0, 30, 85);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.5; controls.maxPolarAngle = Math.PI/2.05;

        scene.add(new THREE.AmbientLight(0xddeedd, 0.2));
        const dirLight = new THREE.DirectionalLight(0xe0ffb0, 0.5);
        dirLight.position.set(40, 80, 40); scene.add(dirLight);

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        composer.addPass(new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.4, 0.02));

        function createCircleTexture() {
          const c = document.createElement('canvas'); c.width=64; c.height=64; const ctx=c.getContext('2d');
          const g = ctx.createRadialGradient(32,32,0,32,32,32); g.addColorStop(0,'rgba(255,255,255,1)'); g.addColorStop(1,'rgba(255,255,255,0)');
          ctx.fillStyle=g; ctx.beginPath(); ctx.arc(32,32,32,0,Math.PI*2); ctx.fill();
          return new THREE.CanvasTexture(c);
        }
        const circleTexture = createCircleTexture();

        // ğŸ„ 1. åœ£è¯æ ‘
        const TREE_HEIGHT=60; const TREE_BASE_RADIUS=24;
        function createPointCloudTree() {
          const pointCount = 10000;
          const positions = new Float32Array(pointCount * 3);
          const colors = new Float32Array(pointCount * 3);
          const dirs = new Float32Array(pointCount * 3);
          const color = new THREE.Color();
          const bands = [
            { t0: 0.00, t1: 0.18, rMul: 1.0 }, { t0: 0.18, t1: 0.35, rMul: 0.9 },
            { t0: 0.35, t1: 0.55, rMul: 0.78 }, { t0: 0.55, t1: 0.75, rMul: 0.65 },
            { t0: 0.75, t1: 0.90, rMul: 0.50 }, { t0: 0.90, t1: 1.00, rMul: 0.35 }
          ];
          function bandRadiusFactor(t) {
            for (let b of bands) if (t >= b.t0 && t < b.t1) return b.rMul;
            return bands[bands.length - 1].rMul;
          }
          for (let i = 0; i < pointCount; i++) {
            const u = Math.random();
            let t; if (u < 0.6) t = u; else { const v = (u - 0.6) / 0.4; t = 0.6 + 0.30 * v; }
            const y = t * TREE_HEIGHT;
            const layer = 1 - t;
            let radiusProfile = TREE_BASE_RADIUS * layer * bandRadiusFactor(t);
            if (t < 0.66) radiusProfile = Math.floor(radiusProfile / 2) * 2 + 1.0;
            else { const smoothT = (t - 0.66) / (1 - 0.66); radiusProfile *= (1.0 - smoothT * 0.10); }
            if (t > 0.80) radiusProfile *= 1.04 + Math.random() * 0.06;
            const radius = radiusProfile * (0.75 + 0.3 * Math.random());
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius;
            positions[i*3] = x; positions[i*3+1] = y - TREE_HEIGHT/2; positions[i*3+2] = z;
            dirs[i*3] = x*3+(Math.random()-0.5)*20; dirs[i*3+1]=(Math.random()-0.5)*60; dirs[i*3+2]=z*3+(Math.random()-0.5)*20;
            const ornamentChance = Math.random();
            if (ornamentChance < 0.06) color.setHSL(0.16, 0.82, 0.72);
            else if (ornamentChance < 0.12) color.setHSL(0.12, 0.85, 0.68);
            else if (ornamentChance < 0.18) color.setHSL(0.30, 0.6, 0.68);
            else if (ornamentChance < 0.26) color.setHSL(0.98, 0.8, 0.58);
            else { const h = 0.32 + 0.03 * Math.random(); const s = 0.65 + 0.2 * Math.random(); const l = 0.16 + 0.22 * layer + 0.08 * Math.random(); color.setHSL(h, s, l); }
            colors[i*3] = color.r; colors[i*3+1] = color.g; colors[i*3+2] = color.b;
          }
          const geo = new THREE.BufferGeometry();
          geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
          geo.userData = { originalPositions: new Float32Array(positions), directions: dirs };
          const mat = new THREE.PointsMaterial({ size: 0.9, map: circleTexture, vertexColors: true, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending });
          const mesh = new THREE.Points(geo, mat); mesh.scale.y = 0.05; mesh.position.y = -TREE_HEIGHT/2*0.95; return mesh;
        }
        const tree = createPointCloudTree(); scene.add(tree);

        // ğŸŒŸ 2. é¡¶éƒ¨æ˜Ÿ
        function createStarTop() {
          const group = new THREE.Group();
          const starShape = new THREE.Shape();
          for (let i = 0; i < 10; i++) {
            const r = (i % 2 === 0) ? 4.0 : 1.8;
            const angle = (i / 10) * Math.PI * 2 + Math.PI / 2;
            const x = Math.cos(angle) * r; const y = Math.sin(angle) * r;
            if (i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
          }
          starShape.closePath();
          const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 1.6, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.4, bevelSegments: 3, steps: 1 });
          starGeo.center();
          const starMat = new THREE.MeshStandardMaterial({ color: 0xffff44, emissive: 0xfff0a0, emissiveIntensity: 0.65, metalness: 0.4, roughness: 0.35 });
          const coreStar = new THREE.Mesh(starGeo, starMat); coreStar.rotation.y = Math.PI; group.add(coreStar);
          const haloCount = 420; const pos = new Float32Array(haloCount * 3); const col = new Float32Array(haloCount * 3); const c = new THREE.Color();
          for (let i = 0; i < haloCount; i++) {
            const r = 3.2 + Math.random() * 3.5; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
            pos[i*3] = r * Math.sin(phi) * Math.cos(theta); pos[i*3+1] = r * Math.cos(phi); pos[i*3+2] = r * Math.sin(phi) * Math.sin(theta);
            const t = Math.random(); c.setHSL(0.14 + 0.04 * t, 0.7, 0.7 + 0.1 * t);
            col[i*3] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
          }
          const haloGeo = new THREE.BufferGeometry(); haloGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3)); haloGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));
          const haloMat = new THREE.PointsMaterial({ size: 0.3, map: circleTexture, vertexColors: true, transparent: true, alphaTest: 0.4, depthWrite: false, blending: THREE.AdditiveBlending });
          const halo = new THREE.Points(haloGeo, haloMat); group.add(halo);
          group.position.set(0, TREE_HEIGHT / 2 - 10, 0); return { group, halo };
        }
        const starObj = createStarTop(); scene.add(starObj.group);

        // ğŸŒ€ 3. èºæ—‹
        function createSpiralSnakeCloud() {
            class SpiralCurve extends THREE.Curve {
                getPoint(t, target = new THREE.Vector3()) {
                    const tt = 0.12 + 0.76 * t; const y = tt * TREE_HEIGHT - TREE_HEIGHT / 2 + 1.5; const layer = 1 - tt;
                    let r = TREE_BASE_RADIUS * layer * 1.03 * (1.05 - 0.2 * t) * (1.0 + 0.04 * Math.sin(tt * 4.0 * Math.PI));
                    const angle = tt * 4.4 * Math.PI * 2;
                    target.set(Math.cos(angle) * r, y, Math.sin(angle) * r); return target;
                }
            }
            const curve = new SpiralCurve(); const count = 800;
            const positions = new Float32Array(count * 3); const colors = new Float32Array(count * 3); const c = new THREE.Color().setHSL(0.16, 0.85, 0.78);
            for (let i = 0; i < count; i++) {
                const t = i / (count - 1); const p = curve.getPoint(t);
                let x = p.x; let y = p.y; let z = p.z;
                const rJitter = (1.5 - 0.8 * t) * 0.4; const a = Math.random() * Math.PI * 2; const off = Math.random() * rJitter;
                x += Math.cos(a) * off; z += Math.sin(a) * off;
                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z; c.toArray(colors, i*3);
            }
            const geo = new THREE.BufferGeometry(); geo.setAttribute("position", new THREE.BufferAttribute(positions, 3)); geo.setAttribute("color", new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 2.0, map: circleTexture, vertexColors: true, transparent: true, opacity: 0, depthWrite: false, blending: THREE.AdditiveBlending });
            const mesh = new THREE.Points(geo, mat); mesh.scale.y = 0.05; mesh.position.y = -TREE_HEIGHT/2*0.95; return mesh;
        }
        const spiralSnake = createSpiralSnakeCloud(); scene.add(spiralSnake);

        // ğŸ”´ 4. çº¢è‰²æŒ‚å 
        function createRedOrnaments() {
            const group = new THREE.Group();
            const baseGeo = new THREE.SphereGeometry(1, 24, 24);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0xcc2233, emissive: 0xff3333, emissiveIntensity: 0.65, metalness: 0.1, roughness: 0.45 });
            for (let k = 0; k < 8; k++) {
                const t = 0.12 + 0.45 * Math.random(); const y = t * TREE_HEIGHT - TREE_HEIGHT / 2;
                const layer = 1 - t; const treeRadius = TREE_BASE_RADIUS * layer * 0.9;
                const theta = Math.random() * Math.PI * 2; const rOut = treeRadius * 1.05;
                const orb = new THREE.Mesh(baseGeo, baseMat);
                const s = 0.7 + Math.random() * 0.4; orb.scale.set(s, s, s);
                orb.position.set(Math.cos(theta) * rOut, y - 0.4 * s, Math.sin(theta) * rOut);
                group.add(orb);
            }
            group.visible = false; return group;
        }
        const redOrnaments = createRedOrnaments(); scene.add(redOrnaments);

        // â„ï¸ 5. é›ªèŠ±
        function createSnow() {
            const c=2000; const pos=new Float32Array(c*3); const spd=new Float32Array(c);
            for(let i=0;i<c;i++){ pos[i*3]=(Math.random()-0.5)*170; pos[i*3+1]=Math.random()*150; pos[i*3+2]=(Math.random()-0.5)*170; spd[i]=0.2+Math.random()*0.5; }
            const geo=new THREE.BufferGeometry(); geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
            const p=new THREE.Points(geo,new THREE.PointsMaterial({color:0xffffff,size:0.8,map:circleTexture,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false}));
            p.userData={spd,rangeY:150}; p.position.y=-10; return p;
        }
        const snow=createSnow(); scene.add(snow);

        // åœ°é¢
        const ground=new THREE.Mesh(new THREE.CircleGeometry(30,64),new THREE.MeshBasicMaterial({color:0x1f6b35,transparent:true,opacity:0.15}));
        ground.rotation.x=-Math.PI/2; ground.position.y=-31; scene.add(ground);

        // === ğŸ 6. 3D æ‚¬æµ®ç¤¼ç‰©ç›’ (äº‘ç•™è¨€å®¹å™¨) ===
        const interactGroup = new THREE.Group();
        scene.add(interactGroup);

        // ç¤¼ç‰©ç›’å‡ ä½•ä½“å¤ç”¨
        const giftGeo = new THREE.BoxGeometry(4, 4, 4);
        const ribbon1Geo = new THREE.BoxGeometry(4.1, 4.1, 1);
        const ribbon2Geo = new THREE.BoxGeometry(1, 4.1, 4.1);
        const giftColors = [0xd11919, 0x118822, 0xd4af37, 0x2266cc, 0xff3366]; // çº¢ç»¿é‡‘è“ç²‰

        function createFloatingGift(message) {
            const group = new THREE.Group();

            // éšæœºé¢œè‰²
            const color = giftColors[Math.floor(Math.random() * giftColors.length)];
            const box = new THREE.Mesh(giftGeo, new THREE.MeshStandardMaterial({ color: color, roughness: 0.4 }));
            const rib1 = new THREE.Mesh(ribbon1Geo, new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }));
            const rib2 = new THREE.Mesh(ribbon2Geo, new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }));

            group.add(box, rib1, rib2);

            // éšæœºåˆ†å¸ƒï¼ˆæ›´è´´è¿‘æ ‘é™„è¿‘ï¼‰
            const angle = Math.random() * Math.PI * 2;
            const minRadius = TREE_BASE_RADIUS * 0.5;   // æ›´é è¿‘æ ‘å¹²
            const maxRadius = TREE_BASE_RADIUS * 1.05;  // ç¨ç¨è¶…å‡ºæ ‘æ
            const radius = minRadius + Math.random() * (maxRadius - minRadius);
            const y = -10 + Math.random() * 30;

            group.position.set(Math.cos(angle) * radius, y, Math.sin(angle) * radius);

            // éšæœºæ—‹è½¬
            group.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

            group.userData = {
                msg: message,
                radius: radius,
                angle: angle,
                speedY: (Math.random()-0.5) * 0.02,
                rotSpeed: {
                    x: (Math.random()-0.5)*0.01,
                    y: (Math.random()-0.5)*0.01
                }
            };
            interactGroup.add(group);
        }

        // åˆå§‹åŠ è½½ç•™è¨€
        fetchWishes().then(wishes => {
            wishes.forEach(msg => createFloatingGift(msg));
        });

        // ç‚¹å‡»æ£€æµ‹ï¼ˆåªè´Ÿè´£å¼€ç¤¼ç‰©å¡ç‰‡ï¼Œä¸å‚ä¸çˆ†ç‚¸ï¼‰
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(interactGroup.children, true);
            if (intersects.length > 0) {
                // æ‰¾åˆ°çˆ¶çº§ Group
                let target = intersects[0].object;
                while(target.parent && target.parent !== interactGroup) target = target.parent;

                const data = target.userData;
                document.getElementById('modal-msg').innerText = data.msg;
                document.getElementById('modal-overlay').style.display = 'flex';
            }
        });

        // === åŠ¨ç”»å¾ªç¯ ===
        const clock = new THREE.Clock();
        function animate() {
          requestAnimationFrame(animate);
          const elapsed = clock.getElapsedTime(); const dt = clock.getDelta();

          controls.autoRotateSpeed = gestureRotateSpeed;
          currentCameraY += (targetCameraY - currentCameraY) * 0.05;
          camera.position.y = currentCameraY;

          // ç¤¼ç‰©ç›’åŠ¨ç”»ï¼šå…¬è½¬ + è‡ªè½¬ + ä¸Šä¸‹æµ®åŠ¨
          interactGroup.children.forEach(obj => {
              // å…¬è½¬
              obj.userData.angle += 0.0005;
              obj.position.x = Math.cos(obj.userData.angle) * obj.userData.radius;
              obj.position.z = Math.sin(obj.userData.angle) * obj.userData.radius;
              // æµ®åŠ¨
              obj.position.y += Math.sin(elapsed + obj.userData.radius) * 0.01;
              // è‡ªè½¬
              obj.rotation.x += obj.userData.rotSpeed.x;
              obj.rotation.y += obj.userData.rotSpeed.y;
          });

          // çˆ†ç‚¸é€»è¾‘
          const targetFactor = interaction.isGrabbing ? 1.0 : 0.0;
          interaction.explosionFactor += (targetFactor - interaction.explosionFactor) * 0.1;
          const isExploding = interaction.explosionFactor > 0.001;

          const tRaw = Math.min(elapsed/4.0, 1.0); const t = 1 - Math.pow(1-tRaw, 3);

          if(!isExploding) {
            const sy = 0.05 + 0.95*t;
            tree.scale.y = sy; tree.position.y = -TREE_HEIGHT/2*(1-sy); tree.material.opacity = t;
            spiralSnake.scale.y = sy; spiralSnake.position.y = tree.position.y; spiralSnake.material.opacity = t;
            starObj.group.position.y = (TREE_HEIGHT/2 - 10) + (8 * t);
            if(t>0.99) redOrnaments.visible = true;
            interactGroup.visible = true;
          } else {
            tree.material.opacity = 1; spiralSnake.material.opacity = 1;
            interactGroup.visible = false;
          }

          if(isExploding) {
            const cur = tree.geometry.attributes.position.array; const org = tree.geometry.userData.originalPositions; const dir = tree.geometry.userData.directions;
            for(let i=0; i<cur.length; i++) cur[i] = org[i] + dir[i]*interaction.explosionFactor;
            tree.geometry.attributes.position.needsUpdate = true;
            spiralSnake.scale.setScalar(1 + interaction.explosionFactor * 2);
            starObj.group.visible = interaction.explosionFactor < 0.5;
            redOrnaments.visible = interaction.explosionFactor < 0.2;
          } else {
            starObj.group.visible = true; if(t>0.99) redOrnaments.visible = true; spiralSnake.scale.setScalar(1);
            if(tree.geometry.attributes.position.needsUpdate) {
               tree.geometry.attributes.position.array.set(tree.geometry.userData.originalPositions);
               tree.geometry.attributes.position.needsUpdate=true; tree.geometry.attributes.position.needsUpdate=false;
            }
          }

          if(!interaction.isGrabbing) starObj.group.rotation.y = elapsed * 0.35;
          starObj.halo.rotation.y = -elapsed * 0.18;
          spiralSnake.rotation.y = Math.sin(elapsed * 0.3) * 0.1;

          // é›ªèŠ± (å¿«é€Ÿä¸‹è½)
          const sPos = snow.geometry.getAttribute('position');
          for(let i=0;i<2000;i++){ sPos.array[i*3+1] -= snow.userData.spd[i]*dt*100; sPos.array[i*3]+=Math.sin((elapsed+i)*0.2)*0.01; if(sPos.array[i*3+1]<-20) sPos.array[i*3+1]=150; }
          sPos.needsUpdate=true;

          controls.update(); composer.render();
        }
        animate();

        window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); composer.setSize(window.innerWidth,window.innerHeight); };
    });
  </script>
</body>
</html>
