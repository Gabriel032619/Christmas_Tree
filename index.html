<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>圣诞树</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont,
        "SF Pro Text", "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #062015 0%, #02050c 55%, #000 100%);
      color: #fff;
    }

    #app {
      position: fixed;
      inset: 0;
    }

    .overlay {
      position: fixed;
      top: 18px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      pointer-events: none;
      z-index: 10;
    }

    .title {
      font-size: clamp(24px, 3vw, 32px);
      letter-spacing: 0.25em;
      text-transform: uppercase;
      text-shadow:
        0 0 10px rgba(200, 255, 160, 0.8),
        0 0 24px rgba(120, 220, 120, 0.8);
    }

    .subtitle {
      margin-top: 6px;
      font-size: 12px;
      opacity: 0.85;
    }

    .chip {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: rgba(0, 0, 0, 0.45);
      margin: 0 3px;
      font-size: 11px;
    }

    .hint {
      position: fixed;
      left: 16px;
      bottom: 16px;
      font-size: 11px;
      opacity: 0.7;
      pointer-events: none;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div class="overlay">
    <div class="title">MERRY CHRISTMAS</div>
    <!-- 这行小字会由 JS 根据 URL 参数自动填充 -->
    <div class="subtitle" id="wish-line"></div>
  </div>

  <div class="hint">
    ✨ Merry Christmas
  </div>

  <!-- 在 three.js 之前：根据 URL 参数设置祝福语 -->
  <script>
    (function () {
      // 默认祝福语
      const defaultWish = "Wishing you peace, joy & love.";
      const params = new URLSearchParams(window.location.search);

      // 支持多种参数名：?wish= / ?msg= / ?text=
      let wishText =
        params.get("wish") ||
        params.get("msg") ||
        params.get("text") ||
        "";

      if (!wishText || !wishText.trim()) {
        wishText = defaultWish;
      }

      // 简单长度限制，防止太长撑坏布局
      wishText = wishText.trim().slice(0, 80);

      const el = document.getElementById("wish-line");
      if (el) {
        el.textContent = wishText;
      }
    })();
  </script>

  <div class="hint">
    ✨ Merry Christmas
  </div>

  <!-- three.js 旧接口版本，兼容 examples/js -->
  <script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://unpkg.com/three@0.140.0/examples/js/shaders/CopyShader.js"></script>

  <script>
    // =============== 0. 圆形点纹理 ===============
    function createCircleTexture() {
      const size = 64;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');

      const grd = ctx.createRadialGradient(
        size / 2, size / 2, 0,
        size / 2, size / 2, size / 2
      );
      grd.addColorStop(0.0, 'rgba(255,255,255,1)');
      grd.addColorStop(0.5, 'rgba(255,255,255,0.9)');
      grd.addColorStop(1.0, 'rgba(255,255,255,0)');

      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();

      const texture = new THREE.CanvasTexture(canvas);
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      return texture;
    }

    const circleTexture = createCircleTexture();

    // =============== 1. 场景基础 ===============
    const container = document.getElementById('app');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.004);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      2000
    );
    camera.position.set(0, 30, 85);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.6;
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.45;
    controls.minDistance = 40;
    controls.maxDistance = 180;
    controls.maxPolarAngle = Math.PI / 2.05;

    const ambient = new THREE.AmbientLight(0xddeedd, 0.18);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xe0ffb0, 0.45);
    dirLight.position.set(40, 80, 40);
    scene.add(dirLight);

    // =============== 2. Bloom ===============
    const renderPass = new THREE.RenderPass(scene, camera);
    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.6,
      0.45,
      0.02
    );
    const composer = new THREE.EffectComposer(renderer);
    composer.addPass(renderPass);
    composer.addPass(bloomPass);

    const TREE_HEIGHT = 60;
    const TREE_BASE_RADIUS = 24;

    // =============== 3. 树：下半层次感，上半圆润尖，且上半每层更矮 ===============
    function createPointCloudTree() {
      const treeHeight = TREE_HEIGHT;
      const baseRadius = TREE_BASE_RADIUS;
      const pointCount = 10000;

      const positions = new Float32Array(pointCount * 3);
      const colors = new Float32Array(pointCount * 3);
      const color = new THREE.Color();

      const bands = [
        { t0: 0.00, t1: 0.18, rMul: 1.0 },
        { t0: 0.18, t1: 0.35, rMul: 0.9 },
        { t0: 0.35, t1: 0.55, rMul: 0.78 },
        { t0: 0.55, t1: 0.75, rMul: 0.65 },
        { t0: 0.75, t1: 0.90, rMul: 0.50 },
        { t0: 0.90, t1: 1.00, rMul: 0.35 }
      ];

      function bandRadiusFactor(t) {
        for (let b of bands) {
          if (t >= b.t0 && t < b.t1) return b.rMul;
        }
        return bands[bands.length - 1].rMul;
      }

      for (let i = 0; i < pointCount; i++) {
        // 非线性分布：上半部分高度压缩
        const u = Math.random(); // [0,1]
        let t;
        if (u < 0.6) {
          t = u;
        } else {
          const v = (u - 0.6) / 0.4; // 0~1
          const topSpan = 0.30;      // 顶部只占总高度 25%
          t = 0.6 + topSpan * v;     // t ∈ [0.6, 0.85]
        }
        const y = t * treeHeight;
        const layer = 1 - t;

        let radiusProfile = baseRadius * layer;
        radiusProfile *= bandRadiusFactor(t);

        // 下半层次感，上半平滑收尖
        if (t < 0.66) {
          radiusProfile = Math.floor(radiusProfile / 2) * 2 + 1.0;
        } else {
          const smoothT = (t - 0.66) / (1 - 0.66); // 0~1
          const shrink = 1.0 - smoothT * 0.10;     // 顶部最多缩 10%
          radiusProfile *= shrink;
        }

        // 顶部轻微扩散，让头部更圆润
        if (t > 0.80) {
          radiusProfile *= 1.04 + Math.random() * 0.06;
        }

        const jitter = 0.75 + 0.3 * Math.random();
        const radius = radiusProfile * jitter;

        const angle = Math.random() * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;

        const idx = i * 3;
        positions[idx] = x;
        positions[idx + 1] = y - treeHeight / 2;
        positions[idx + 2] = z;

        const ornamentChance = Math.random();

        if (ornamentChance < 0.06) {
          color.setHSL(0.16, 0.82, 0.72);   // 明黄
        } else if (ornamentChance < 0.12) {
          color.setHSL(0.12, 0.85, 0.68);   // 柔黄
        } else if (ornamentChance < 0.18) {
          color.setHSL(0.30, 0.6, 0.68);    // 黄绿
        } else if (ornamentChance < 0.26) {
          color.setHSL(0.98, 0.8, 0.58);    // 偏暗红灯
        } else {
          const h = 0.32 + 0.03 * Math.random();
          const s = 0.65 + 0.2 * Math.random();
          const l = 0.16 + 0.22 * layer + 0.08 * Math.random();
          color.setHSL(h, s, l);
        }

        colors[idx] = color.r;
        colors[idx + 1] = color.g;
        colors[idx + 2] = color.b;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.9,
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        alphaTest: 0.4,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      const points = new THREE.Points(geometry, material);
      points.name = 'treePointCloud';
      return points;
    }

    const tree = createPointCloudTree();
    scene.add(tree);

    // =============== 4. 顶部淡黄色五角星 ===============
    function createStarTop() {
      const group = new THREE.Group();

      // ---- 1. 定义 2D 五角星形状 ----
      const outerRadius = 4.0;   // 外圈半径：控制星星整体大小
      const innerRadius = 1.8;   // 内圈半径：控制星星尖锐程度

      const starShape = new THREE.Shape();
      const totalPoints = 10;    // 外点 + 内点 交替 = 10

      for (let i = 0; i < totalPoints; i++) {
        const isOuter = (i % 2 === 0);
        const r = isOuter ? outerRadius : innerRadius;
        const angle = (i / totalPoints) * Math.PI * 2 + Math.PI / 2; // 从正上方开始

        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;

        if (i === 0) {
          starShape.moveTo(x, y);
        } else {
          starShape.lineTo(x, y);
        }
      }
      starShape.closePath();

      // ---- 2. 将 2D 星形挤出为有厚度的 3D 星星 ----
      const extrudeSettings = {
        depth: 1.6,           // 厚度
        bevelEnabled: true,
        bevelThickness: 0.5,
        bevelSize: 0.4,
        bevelSegments: 3,
        steps: 1
      };

      const starGeo = new THREE.ExtrudeGeometry(starShape, extrudeSettings);
      starGeo.center();  // 把星星中心移到 (0,0,0)

      const starMat = new THREE.MeshStandardMaterial({
        // 淡黄色主色
        // color: 0xfff5c0,
        color: 0xffff44,
        // 柔和自发光，让它微微亮一点
        emissive: 0xfff0a0,
        emissiveIntensity: 0.65,
        metalness: 0.4,
        roughness: 0.35
      });

      const coreStar = new THREE.Mesh(starGeo, starMat);
      // 让星星正面朝向摄像机（树在 Y 轴旋转，这样看什么角度都 OK）
      coreStar.rotation.y = Math.PI;
      group.add(coreStar);

      // ---- 3. 淡黄色光晕点云 Halo ----
      const haloCount = 420;
      const pos = new Float32Array(haloCount * 3);
      const col = new Float32Array(haloCount * 3);
      const c = new THREE.Color();

      for (let i = 0; i < haloCount; i++) {
        const r = 3.2 + Math.random() * 3.5;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);

        const x = r * Math.sin(phi) * Math.cos(theta);
        const y = r * Math.cos(phi);
        const z = r * Math.sin(phi) * Math.sin(theta);

        const idx = i * 3;
        pos[idx]     = x;
        pos[idx + 1] = y;
        pos[idx + 2] = z;

        const t = Math.random();
        // 淡黄色到微暖白色的渐变
        c.setHSL(0.14 + 0.04 * t, 0.7, 0.7 + 0.1 * t);
        col[idx]     = c.r;
        col[idx + 1] = c.g;
        col[idx + 2] = c.b;
      }

      const haloGeo = new THREE.BufferGeometry();
      haloGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      haloGeo.setAttribute('color', new THREE.BufferAttribute(col, 3));

      const haloMat = new THREE.PointsMaterial({
        size: 0.3,
        map: circleTexture,       // 用你前面生成的圆形纹理
        vertexColors: true,
        transparent: true,
        alphaTest: 0.4,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      const halo = new THREE.Points(haloGeo, haloMat);
      group.add(halo);

      // ---- 4. 星星整体位置：略高于树尖一点点 ----
      group.position.set(0, TREE_HEIGHT / 2 - 2, 0);

      return { group, halo };
    }

    // 保持这两行不变
    const starObj = createStarTop();
    scene.add(starObj.group);

    // =============== 5. 蛇形淡黄色点云螺旋（底部更粗，上部更细） ===============
    class SpiralCurve extends THREE.Curve {
      constructor(height, baseRadius) {
        super();
        this.height = height;
        this.baseRadius = baseRadius;
      }

      getPoint(t, target = new THREE.Vector3()) {

        // 螺旋从 12% 高度开始，到 88% 高度结束
        const tt = 0.12 + 0.76 * t;

        // 垂直高度
        const y = tt * this.height - this.height / 2 + 1.5;

        // 跟随树的层级
        const layer = 1 - tt;
        let rTree = this.baseRadius * layer;

        // ⭐ 关键：蛇形随高度变细
        // 底部更粗（1.35），顶部细一点（0.95）
        const thickness = 1.05 - (1.15 - 0.95) * t;

        // 对树半径进行扩展，让蛇“刚好比树大一点”
        let r = rTree * 1.03 * thickness;

        // 轻微起伏，让曲线不死板
        r *= 1.0 + 0.04 * Math.sin(tt * 4.0 * Math.PI);

        // 螺旋圈数
        const turns = 4.4;
        const angle = tt * turns * Math.PI * 2;

        const x = Math.cos(angle) * r;
        const z = Math.sin(angle) * r;

        target.set(x, y, z);
        return target;
      }
    }

    function createSpiralSnakeCloud() {
      const curve = new SpiralCurve(TREE_HEIGHT, TREE_BASE_RADIUS);

      const count = 800; // ★ 更细腻的蛇（原来 800 太少）
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);

      // 淡黄色
      const color = new THREE.Color();
      color.setHSL(0.16, 0.85, 0.78);

      for (let i = 0; i < count; i++) {
        const t = i / (count - 1);
        const p = curve.getPoint(t);

        let x = p.x;
        let y = p.y;
        let z = p.z;

        // ★ 蛇的粗细随高度变化
        const radiusJitter = (1.5 - 0.8 * t) * 0.4;
        const angle = Math.random() * Math.PI * 2;
        const offset = Math.random() * radiusJitter;

        x += Math.cos(angle) * offset;
        z += Math.sin(angle) * offset;

        const idx = i * 3;
        positions[idx] = x;
        positions[idx + 1] = y;
        positions[idx + 2] = z;

        color.toArray(colors, idx);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 2.0,              // ★ 更粗一点
        map: circleTexture,
        vertexColors: true,
        transparent: true,
        alphaTest: 0.4,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });

      const points = new THREE.Points(geometry, material);
      points.name = "spiralSnakeCloud";
      return points;
    }

    const spiralSnake = createSpiralSnakeCloud();
    scene.add(spiralSnake);

    // =============== 6. 红色实心球挂坠（Mesh 版） ===============
    function createRedOrnaments() {
      const group = new THREE.Group();

      const orbCount = 8;           // 挂坠数量
      const baseRadiusScale = 0.9;   // 挂坠距离树中心的大致比例

      // 复用同一个几何体和材质，性能更好
      const baseGeometry = new THREE.SphereGeometry(1, 24, 24); // 半径1，后面用缩放微调
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0xcc2233,     // 深一点的红色，避免太艳
        emissive: 0xff3333,       // 红色自发光
        emissiveIntensity: 0.65,  // 发光强度提高
        metalness: 0.1,
        roughness: 0.45
      });

      for (let k = 0; k < orbCount; k++) {
        // 挂在树的中下部区域：t 越小越靠下
        const t = 0.12 + 0.45 * Math.random(); // 约 0.12 ~ 0.57
        const y = t * TREE_HEIGHT - TREE_HEIGHT / 2;

        const layer = 1 - t;
        const treeRadius = TREE_BASE_RADIUS * layer * baseRadiusScale;

        // 挂在树外侧一点点
        const theta = Math.random() * Math.PI * 2;
        const rOut = treeRadius * 1.05;  // 比树稍微大一点
        const cx = Math.cos(theta) * rOut;
        const cz = Math.sin(theta) * rOut;
        const cy = y;

        // 实例化一个小球
        const orb = new THREE.Mesh(baseGeometry, baseMaterial);
        // 每颗灯稍微有点大小差异
        const s = 0.7 + Math.random() * 0.4; // 0.7~1.1 倍
        orb.scale.set(s, s, s);

        // 位置：略微随重力方向偏一点，让它看起来“挂着”
        orb.position.set(
          cx,
          cy - 0.4 * s,
          cz
        );

        group.add(orb);
      }

      group.name = 'redOrnamentsMesh';
      return group;
    }

    const redOrnaments = createRedOrnaments();
    scene.add(redOrnaments);

    // =============== 7. 雪花点云 ===============
    function createSnow() {
      const snowCount = 1800;
      const positions = new Float32Array(snowCount * 3);
      const speeds = new Float32Array(snowCount);

      const rangeX = 170;
      const rangeY = 150;
      const rangeZ = 170;

      for (let i = 0; i < snowCount; i++) {
        const idx = i * 3;
        positions[idx]     = (Math.random() - 0.5) * rangeX;
        positions[idx + 1] = Math.random() * rangeY;
        positions[idx + 2] = (Math.random() - 0.5) * rangeZ;

        speeds[i] = 0.04 + Math.random() * 0.12;
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.85,
        map: circleTexture,
        transparent: true,
        alphaTest: 0.4,
        depthWrite: false,
        blending: THREE.AdditiveBlending
      });

      const snow = new THREE.Points(geometry, material);
      snow.userData = { speeds, rangeY };
      snow.position.y = -10;
      return snow;
    }

    const snow = createSnow();
    scene.add(snow);

    // =============== 8. 底部柔光 ===============
    (function addGroundGlow() {
      const geo = new THREE.CircleGeometry(28, 64);
      const mat = new THREE.MeshBasicMaterial({
        color: 0x1f6b35,
        transparent: true,
        opacity: 0.18
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.rotation.x = -Math.PI / 2;
      mesh.position.y = -30.5;
      scene.add(mesh);
    })();

    // =============== 9. 动画循环 ===============
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);

      const delta   = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      starObj.group.rotation.y = elapsed * 0.35;
      starObj.halo.rotation.y  = -elapsed * 0.18;
      const pulse = 1 + Math.sin(elapsed * 1.7) * 0.03;
      starObj.group.scale.setScalar(pulse);

      spiralSnake.rotation.y = Math.sin(elapsed * 0.3) * 0.1;

      const posAttr = snow.geometry.getAttribute('position');
      const speeds  = snow.userData.speeds;
      const rangeY  = snow.userData.rangeY;

      for (let i = 0; i < speeds.length; i++) {
        const idx = i * 3;
        posAttr.array[idx + 1] -= speeds[i] * delta * 60;
        posAttr.array[idx]     += Math.sin((elapsed + i) * 0.11) * 0.017;
        posAttr.array[idx + 2] += Math.cos((elapsed + i) * 0.10) * 0.017;

        if (posAttr.array[idx + 1] < -20) {
          posAttr.array[idx + 1] = rangeY;
        }
      }
      posAttr.needsUpdate = true;

      controls.update();
      composer.render(delta);
    }

    animate();

    // =============== 10. 自适应窗口 ===============
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>